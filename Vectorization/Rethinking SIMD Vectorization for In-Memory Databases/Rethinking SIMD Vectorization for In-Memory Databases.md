# Rethinking SIMD Vectorization for In-Memory Databases





## 相关知识学习



SIMD指令的三个步骤，load，运算，store，为什么是这样呢？其实要先弄清楚为什么能并行运算，这是因为处理器厂商向cpu中加入了新的寄存器，寄存器的宽度长了，这样就可以并行处理了，所以，我们用SIMD的第一步就是，先将数据从**内存**load到专用**寄存器**中，然后在该寄存器中进行处理，最后再从寄存器store回内存中。

---

https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html

这里介绍一下SIMD指令集函数的命令规则：SIMD指令集的数据类型命令主要有\__m128、\__m128i、\__128d、\__m256、\__m256i、\__m256d等等，默认为单精度(d表示双精度, i表示整型)，其函数的命令大致分为3个部分，3个部分之间由“ _ ”隔开，含义如下：

- 第一部分为\_mm或\_mm256。\_mm表示其为SSE指令，操作的向量长度为64为或128位。\_mm256表示AVX指令，操作的向量长度为256位。
- 第二部分为操作函数名称，如\_add、\_load、\_mul等，一些函数操作会增加修饰符，如loadu表示不对齐到向量长度的存储器访问。
- 第三部分为操作的对象名及数据类型，\_ps表示操作向量中所有的单精度数据；\_pd表示操作向量中所有的双精度数据；\_pixx表示操作向量中所有的xx位的有符号整型数据，向量寄存器长度为64位；\_epixx表示操作向量中所有的xx位的有符号整型数据，向量寄存器长度为128位；\_epuxx表示操作向量中所有的xx位的无符号整型数据，向量寄存器长度为128位；\_ss表示只操作向量中第一个单精度数据；si128表示操作向量寄存器中的第一个128位有符号整型。





## 3. FUNDAMENTAL OPERATIONS

本章介绍了4个向量化的基础操作，后面在向量化数据库操作时会用到这些基础操作。

- selective load/store 根据掩码将数据从**连续**内存load，或者store到内存
- gather/scatter 根据索引将数据从**离散**的内存load或store

附件C介绍了selective load/store的实现方式，其实就是用两个SIMD指令组合一下。



## 4. SELECTION SCANS

本章介绍如何将OLAP数据库常见操作：选择性扫描，应用向量化来加速。

扫描就是遍历全表，然后对每个tuple做表达式求值，如果表达式求值的结果为true，则输出该tuple。

通过之前读论文ROVEC我们知道，ROVEC就是用向量化加速表达式求值的过程，最终输出的结果是一个bit vector，记录要选择哪个tuple。而本文就是在已经有了这个bit vector的前提下，继续用向量化加速scan。

注意，本文把bit vector称为mask掩码。



**Branching & Branchless**

首先给了scan算法的两个实现版本，分别为算法一和算法二，这两个版本是带分支和不带分支的版本。线性选择扫描的性能与分支预测错误有关，因为现代cpu的流水线技术，使得同一个cycle内执行多条指令，但遇到if他也默认true执行，如果if的实际结果是false，那么就需要清空流水线，重新执行，导致性能不佳。



**Selectivity**

考虑完无分支版本后，下面要考虑的一个点是选择率问题。试想这样一种情况，你把数据都加载到寄存器了，但是mask表示只会把其中一个数据store到内存，即选择率非常低，这样就浪费了大量的带宽。

为了解决这个问题，引入了一个缓存buffer，将mask中要选择的数据的索引存入buffer中，当buffer满时，再根据buffer中的索引将实际的数据存入对应的位置。



## 5. HASH TABLES
哈希表经常被使用，比如再hash join中，会给一个表建立哈希表，然后遍历另外一个表的同时查询这个哈希表中目标行的索引。

为了提高哈希表的利用率，现在的一个优化方案时cuckoo hash table，将原来的一个元素替换为一个桶。因此，可以考虑在桶上应用向量化技术，即一个key同时与桶中所有的key比较。但是呢，这个方案并不能带来性能的明显提升，因为它不能充分利用simd的寄存器，这里，文中将这个技术称为horizontal vectorization。

本文提出了一个新的技术：vertical vectorization来加速哈希表线性探测的过程，没错，不是cuckoo hash的思路，是线性探测方案。最原本的线性探测是从hash(k)指示的位置开始一直找到空位置为止。加入向量化的思想后，这里一次处理多个key查询的请求，将多个key存入向量寄存器，首先对他们求哈希结果，然后利用gather操作获得这些哈希结果对应的key，之后对比这些key，相同的地方标1，否则标0，输出result bit vector。替换掉那些已经对比完成的key，用后面待查询的key来顶替，然后那些在向量寄存器中没对比完成的key的offset需要加一，再次重复上述过程，区别在于通过哈希值gather对应key时，需要加上偏移。

（具体的图请参考参考文献）













## 参考文献

> https://zhuanlan.zhihu.com/p/432895054
>
> https://zhuanlan.zhihu.com/p/478848608