# Sketch





## Simply Sampling

**简单抽样：**当面临大量数据需要处理的情况，一个比较简单的想法就是忽略大部分数据，仅从完整的数据中抽取部分数据来进行处理。并将从部分数据集中得到的结论推广至完整数据集。为了使结论更加可信，抽样的数据必须是随机的。



**最基本的抽样方法是：**均匀随机抽样法（uniform random sampling）。对于一个大数据集，我们随机从该大数据集中挑选少量的数据组成Sample，然后，很多问题均可通过简单分析Sample来解决。



**基本问题：**

1. Sample应该抽样多少是数据才能提供一个较好的效果？
	- 大小为s的Sample样本的标准误差与$1/\sqrt{s}$成正比
	- 也即，假设Sample有1000个样本，则误报率大概为3%。如果希望误报率为0.3%，则Sample需要100000个样本。
2. Sample如何抽样，才能保证是均匀随机的？
	- 需要保证每个数据被抽样的概率是相同的
	- 一个简单的方案：给每个数据赋予一个随机数，按照随机数进行排序，取前s个数据作为Sample
3. 当新的数据不断到来，如何维持（更新）Sample？
	- 一个简单的方案：当一个新item数据到来，有p概率将其放入Sample
	- 如果想维持Sample的大小不变，则给所有的数据赋予一个随机标签，然后按照标签排序，永远取前s个标签对应的数据



**应用场景：**

1. 数据库管理系统DBMS中，做查询优化，为了评估不同查询方案的性能，往往会将不同查询方案在Sample进行测试和比较。
2. 在做数据集成时，判断两个Table中两个Columns是否相关时，如果是两个Table的所有数据进行对比，太耗时，因此往往抽样部分数据来提高处理效率。





## Bloom Filter

**布隆过滤器：**是一种近似集合成员资格查询数据结构，用于判断某个元素是否被存储，非常节省空间，但存在误报的情况（假阳性，即元素不存在，但Bloom Filter表示存在）。

布隆过滤器表示元素不存在，则该元素一定不存在；布隆过滤表示元素存在，则该元素可能存在也可能不存在。

（关于布隆过滤器的详细介绍很多，本文就不赘述了）



**应用场景：**

利用布隆过滤器，能够过滤掉大量不符合条件的请求，少量请求需要二次确认。因此，系统性能得到提升。

- 黑名单系统。假设有100亿个黑名单URL，每个URL大小为64字节。则数据库存储这些数据需要640GB，而使用Bloom Filter，如果不允许误报，即为每个URL分配1bit的位置，则需要100亿个1bit，即1.2GB。这是个比较极端的例子，一般来说不会有这么大的数据。
	- 假设有MB级别的黑名单，则一般浏览器不会将其存在用户本地，而是放在服务器上，如果每次访问网页都去请求服务器，不仅耗时，而且服务器承受压力太大。
	- 如果换用Bloom Filter，仅用KB级别就可以存储所有数据，这样就可以放在用户本地。访问网页时，先在本地判断，若Bloom Filter返回不存在，则该网页一定不在黑名单中，若Bloom Filter返回存在，则再去服务器二次确认。
- 分布式数据库（Distributed Database）。如Google’s Bigtable，Apache’s Cassandra，HBase。Bloom Filter作为分布式数据块的索引，记录数据库的什么行或列被存储在磁盘上，以此避免了对磁盘上不存在数据的耗时访问。



## Count-Min Sketch

**背景：**当你需要记录某个元素item出现的次数时，可以考虑用计数器记录，该元素每出现一次，计数器就加一。当你需要记录多个元素出现的次数时，一种简单的方案是，为每个元素设置一个计数器。但是这种方案有两个缺点：（1）每当出现一个新元素时，都需要为其创建计数器（2）当元素出现次数太多时，则计数器的大小就需要设置的很大，比较浪费空间。当计数器的大小超过内存时，则就需要访问慢速的存储器，效率会大大降低。

举个例子，在Twitter中，需要记录每个推文被访问的次数，因此为每个推文设置一个计数器，然而，总推文数量高达几十亿，因此这将耗费大量的空间，此方案不可取。



**Count-Min Sketch：**

它能够保证对于大量的计数需求来说，是准确的；但对于小量的计数需求来说，不是很准确



数据结构：

- 一个二维数组（m×n），数组中的每个位置是一个计数器
- m个哈希函数，哈希函数的映射范围为[0, n]



插入操作：

- 每个哈希函数对应二维数组中的一行，将元素映射到该行上的某个计数器中，计数器加一
- 每行都找一个计数器加一



查询操作：

- 为了查询某个元素出现的次数
- 在数组的每行中找到该元素对应的计数器，把这些计数器中的最小值作为该元素出现的次数



![](.\img\Snipaste_2022-05-26_19-35-07.png)



由于哈希冲突的原因，因此每个计数器不可能被一个元素单独占用，所以我们找数值最小的计数器来近似表示元素出现的次数。





**讨论：**

- 很大概率上，Count-Min Sketch返回的结果是接近真实结果的
- 返回结果的准确性依赖于二维数组的行数和列数